# C复习

[TOC]

## 简介

ANSI C为C语言的标准

C语言特点：简单，快速，高性能，兼容性好。

cc编译器最早出现在Unix下，用于编译C语言，后来出现了很多兼容cc编译器的编译器。其中最著名的就是gcc，且它是开源免费的。



## vim简介

`a` : 当前位置插入

`i` : 当前位置插入

`o` : 下一行开头插入

`shift+o` : 上一行插入

`shift+i` : 行首插入

`shift+a` : 行尾插入

`:wq`: 保存并退出

`x` : 删除当前字符

`dd` : 删除当前行

`:sp [filename]` : 打开另一个文件

`:set nu` ：显示行号

`[num] dd` : 当前行后多少行进行剪切

`p` : 进行粘贴



## 多文件编译

只有含有`main`函数的c文件被编译器编译之后才会生成可执行的`.out`文件，不然被编译的文件不能执行。

一般使用编译指令为：(gcc为例子)

```
gcc [filename....] -o [output_filename]
```

当在使用`#include`导入`.c`文件的时候，相当于拷贝代码。`.o`文件相当于编译完了已经拷贝的代码。不需要进行编译，只需要去使用即可。

所以最佳实践是：当我们不长改变的函数等，进行编译成`.o`文件去使用，效率很高。



## Make工具

make内部使用的是gcc。

告诉哪些是源代码，文件之间的关系。所以我们需要在`makefile`中进行说明。

例如: 

```Makefile
# this is a makefile example
# 目标文件:源文件列表
hello.out:max.o min.o hello.c
# 编译指令，编译多个文件，生成hello.out文件
	gcc max.o min.o hello.c -o hello.out
max.o:max.c
# 编译单个文件，编译后文件名称为max.o
	gcc -c max.c
min.o:min.c
	gcc -c min.c
```

`make`指令进行编译。文件被修改了之后，使用`make`会被重新进行编译。



## Main函数

main函数参数为`int argc, char* argv[]`第一个是参数个数，第二个为字符串数组。

main函数的返回值是有意义的，在linux中，有命令`&&`，当前一个命令返回0时，才会执行后面的一个命令。main函数的返回值就是这个意思。

所以main函数的返回值可以让我们很好的用于实现shell脚本。



## 输入输出流

###  概念

在启动`.c`文件的时候，系统会为我们打开三个文件：

- `stdin` : 标准输入，默认是键盘

  ```c
  scanf(stdin, "%d", &a);
  // 相当于
  fscanf("%d", &a);
  ```

- `stdout` : 标准输出，默认是显示器

  ```c
  printf("hello world");
  // 相当于
  fprintf(stdout, "hello world");
  ```

- `stderr` : 标准错误输出

  ```c
  fprintf(stderr, "something error");
  ```

### 重定向

0 : 标准输入流

1 : 标准输出流

2 : 标准错误输出流

`>>`输出流重定向，不会覆盖文件内容，标准输出流是`1>>`，标准错误输出流`2>>`，默认就是标准输出流。

`>`输出流重定向，会覆盖，标准输出流是`1>`，标准错误输出流`2>`，默认就是标准输出流。

`<`输入流重定向

```shell
./a.out 1> stdout.txt 2> stderr.txt < stdin.txt
```



## 管道

`|`表示管道，将前一个指令的结果(输出流)作为下一个指令的输入流。



## 指针与内存

字节是内存的基本单位，一个字节就是一个内存单元。

寻址能力指的是在内存中寻找数据的能力，所谓32位寻址，就是内存中的每个单元都是由32个二进制数标明的，所以最多可安装2的32次方也就是4GB大的内存。

32位CPU有32根数据总线，每根总线有0和1，也就是每次寻址可以寻出一个32bit的单元。那一共可以寻出多少个单元呢。即0x0000-0xffff，是4G个。因此是4GB。这里的B，实际上是指内存单元，也就是单片机书上示意图里的一行。

但是在windows中，存在一种技术，叫做PAE（物理地址扩展），是基于x86的服务器的一种功能，它运行在windows server 2003, Enterpise Edition和windows server 2003, Datacenter Edition的计算机可以支持4GB以上物理内存。物理地址扩展 (PAE) 允许将最多64GB 的物理内存用作常规的4 KB 页面，并扩展内核能使用的位数以将物理内存地址从32扩展到64。但是最大内存支持是256G。

系统会对内存进行规划，只有一部分内存是可以被用户使用的。  ![1-1](_image/1-1.png)

系统内核占用的内存是高位内存，一般  是fffffffff... ~ 7ffffffff….

数据段：存放全局变量，静态常量，静态函数，静态类等。

代码段：存放代码指令。

堆：程序动态创建的内存

栈：存储当前执行的指令，用于记录程序执行过程，函数进栈，出栈，函数参数，函数内部变量等。

*数据段和代码段是固定的，所有程序共用这个空间*

*GCC编译器会对代码的进行优化，会将所有变量进行再一起声明，说有指针变量在一起声明，这样就会造成一种现象：代码声明的变量地址和实际的地址可能不连续*

## 字符串与数组

数组名称表示数组第一个元素的地址。

```c
int arr[10] = {0};
// arr 表示 &arr[0]
// arr[1] <=> *(&arr[0])
```

## 预处理及宏定义

编译有4步骤：

- `.c`文件生成`.i`文件：预处理

  预处理做的第一件事就是展开了头文件。第二件事就是宏替换。

  在这个阶段，不考虑语法的，宏的替换其实就是字符串的替换。

  宏函数：

  ```c
  #define M(n) n*n

  int a = M(2); // 其实就是int a = 2*2; 注意是2*2不是4，只是简单的字符串替换而已
  ```

  还有条件编译`#ifdef #else #endif #ifndef等`

  `typedef`用于给变量起别名。经过预处理后，并不会被替换为原来的名字。

- `.i`文件生成`.s`文件：编译

- `.s`文件生成`.o`文件：汇编

- `.o`文件生成可执行文件：链接

## 结构体

字节对齐，主要让计算机快速读写，是一种用空间换取时间的方式。

结构体大小 = 最后一个成员的偏移量 + 最后一个成员的大小 + 末尾的填充字节数

- 偏移量：成员实际地址和首地址之间的距离

字节对齐的时候，有这样的一条准则：每个成员相对于结构体首地址的偏移量，都得是当前成员所占内存大小的整数倍，如果不是编译器就会在成员之间加上填充字节。最后，编译器需要判断结构体总大小是不是结构体中最宽的*基本类型*成员大小的整数倍。如果不能被整除，需要在最后做字节填充。

没有太多可讲的，和数组很相似。

## 共用体

让几个不同类型的变量共享共同地址。同一时刻只能存储一个成员。

共用体长度为成员中数据类型最大的大小。

## 动态数据结构

链表

## 位运算

按位`&`和`|`

按位异或`^`

`<<`和`>>`